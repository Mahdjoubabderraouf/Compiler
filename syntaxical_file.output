Terminals unused in grammar

    mcELSE
    point
    or
    aro
    gui
    commantaire
    UNARY_OPERATOR


Grammar

    0 $accept: Fonction $end

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF DECLARATIONS INSTR1 identificateur eq EXPR mcENDR Fonction
    2         | mcPROGRAM identificateur DECLARATIONS INSTR1 mcEND

    3 DECLARATIONS: type identificateur caractere1 DECLARATIONS1

    4 caractere1: etoile INTEGER
    5           | ε

    6 DECLARATIONS1: point_virgule DECLARATIONS
    7              | point_virgule
    8              | virgule identificateur caractere1 DECLARATIONS1
    9              | mcDIMENSION paraO INTEGER paraF DECLARATIONS2
   10              | mcDIMENSION paraO INTEGER virgule INTEGER paraF DECLARATIONS2
   11              | eq VALEURS DECLARATIONS1

   12 DECLARATIONS2: point_virgule DECLARATIONS
   13              | point_virgule
   14              | virgule identificateur caractere1 DECLARATIONS1
   15              | mcDIMENSION paraO INTEGER paraF DECLARATIONS1
   16              | mcDIMENSION paraO INTEGER virgule INTEGER paraF DECLARATIONS1

   17 VALEURS: REAL
   18        | INTEGER
   19        | caracter
   20        | chaine

   21 type: mcINTEGER
   22     | mcLOGICAL
   23     | mcREAL
   24     | mcCHARACTER

   25 INSTR1: INSTR1 INSTR point_virgule
   26       | ε

   27 INSTR: Affectation
   28      | ES
   29      | Condition
   30      | Boucle
   31      | Appel
   32      | Equivalence
   33      | ε

   34 Affectation: identificateur eq EXPR

   35 EXPR: CHAINE_STRING
   36     | MATH_VAR
   37     | APPEL_FONC
   38     | mcFALSE
   39     | mcTRUE

   40 APPEL_FONC: mcCALL identificateur paraO Liste paraF

   41 MATH_VAR: identificateur MATH_VAR1
   42         | identificateur paraO INTEGER paraF MATH_VAR1
   43         | identificateur paraO INTEGER virgule INTEGER paraF MATH_VAR1
   44         | INTEGER MATH_VAR1
   45         | INTEGERPOSITIF MATH_VAR1
   46         | INTEGERNEGATIF MATH_VAR1
   47         | REAL MATH_VAR1
   48         | REALPOSITIF MATH_VAR1
   49         | REALNEGATIF MATH_VAR1
   50         | paraO MATH_VAR paraF MATH_VAR1

   51 MATH_VAR1: OPER MATH_VAR
   52          | INTEGERNEGATIF OPER MATH_VAR
   53          | INTEGERPOSITIF OPER MATH_VAR
   54          | REALNEGATIF OPER MATH_VAR
   55          | REALPOSITIF OPER MATH_VAR
   56          | INTEGERNEGATIF
   57          | INTEGERPOSITIF
   58          | REALNEGATIF
   59          | REALPOSITIF
   60          | ε

   61 CHAINE_STRING: IDFI_CHAR CHAINE_STRING1

   62 CHAINE_STRING1: plus IDFI_CHAR CHAINE_STRING1
   63               | mpins IDFI_CHAR CHAINE_STRING1
   64               | ε

   65 IDFI_CHAR: chaine
   66          | caracter

   67 ES: mcREAD paraO identificateur paraF
   68   | mcWRITE paraO chaine paraF
   69   | mcWRITE paraO chaine ES_WRITE_OPTIONAL paraF

   70 ES_WRITE_OPTIONAL: virgule identificateur
   71                  | virgule identificateur chaine

   72 Condition: mcIF paraO EXPR_CONDI paraF mcTHEN INSTR mcENDIF

   73 Boucle: mcDOWHILE paraO EXPR_CONDI paraF INSTR mcENDO

   74 Appel: identificateur paraO Liste paraF

   75 Equivalence: PartageMemoire paraO Liste paraF virgule paraO Liste paraF

   76 EXPR_CONDI: EXPR_CONDI_TYPE EXPR_CONDI_SUITE

   77 EXPR_CONDI_TYPE: identificateur
   78                | mcTRUE
   79                | mcFALSE
   80                | INTEGER
   81                | REAL
   82                | paraO EXPR_CONDI paraF

   83 EXPR_CONDI_SUITE: EXPR_CONDI_OP EXPR_CONDI_TYPE EXPR_CONDI_SUITE
   84                 | point_virgule
   85                 | ε

   86 EXPR_CONDI_OP: OR
   87              | AND
   88              | GT
   89              | GE
   90              | EQ
   91              | NE
   92              | LE
   93              | LT
   94              | paraO EXPR_CONDI paraF
   95              | OPER

   96 Liste: identificateur
   97      | Liste virgule identificateur

   98 OPER: plus
   99     | mpins
  100     | etoile
  101     | division


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    mcTRUE (258) 39 78
    mcFALSE (259) 38 79
    mcINTEGER (260) 21
    mcREAL (261) 23
    mcCHARACTER (262) 24
    mcLOGICAL (263) 22
    mcREAD (264) 67
    mcWRITE (265) 68 69
    mcDIMENSION (266) 9 10 15 16
    mcPROGRAM (267) 2
    mcEND (268) 2
    mcROUTINE (269) 1
    mcENDR (270) 1
    mcCALL (271) 40
    mcIF (272) 72
    mcTHEN (273) 72
    mcELSE (274)
    mcENDIF (275) 72
    mcDOWHILE (276) 73
    mcENDO (277) 73
    PartageMemoire (278) 75
    OR (279) 86
    AND (280) 87
    GT (281) 88
    EQ (282) 90
    GE (283) 89
    NE (284) 91
    LE (285) 92
    LT (286) 93
    eq (287) 1 11 34
    point_virgule (288) 6 7 12 13 25 84
    point (289)
    plus (290) 62 98
    mpins (291) 63 99
    division (292) 101
    or (293)
    aro (294)
    etoile (295) 4 100
    virgule (296) 8 10 14 16 43 70 71 75 97
    gui (297)
    paraO (298) 1 9 10 15 16 40 42 43 50 67 68 69 72 73 74 75 82 94
    paraF (299) 1 9 10 15 16 40 42 43 50 67 68 69 72 73 74 75 82 94
    identificateur (300) 1 2 3 8 14 34 40 41 42 43 67 70 71 74 77 96 97
    INTEGER (301) 4 9 10 15 16 18 42 43 44 80
    INTEGERPOSITIF (302) 45 53 57
    INTEGERNEGATIF (303) 46 52 56
    REAL (304) 17 47 81
    caracter (305) 19 66
    chaine (306) 20 65 68 69 71
    commantaire (307)
    REALNEGATIF (308) 49 54 58
    REALPOSITIF (309) 48 55 59
    UNARY_OPERATOR (310)


Nonterminals, with rules where they appear

    $accept (56)
        on left: 0
    Fonction (57)
        on left: 1 2
        on right: 0 1
    DECLARATIONS (58)
        on left: 3
        on right: 1 2 6 12
    caractere1 (59)
        on left: 4 5
        on right: 3 8 14
    DECLARATIONS1 (60)
        on left: 6 7 8 9 10 11
        on right: 3 8 11 14 15 16
    DECLARATIONS2 (61)
        on left: 12 13 14 15 16
        on right: 9 10
    VALEURS (62)
        on left: 17 18 19 20
        on right: 11
    type (63)
        on left: 21 22 23 24
        on right: 1 3
    INSTR1 (64)
        on left: 25 26
        on right: 1 2 25
    INSTR (65)
        on left: 27 28 29 30 31 32 33
        on right: 25 72 73
    Affectation (66)
        on left: 34
        on right: 27
    EXPR (67)
        on left: 35 36 37 38 39
        on right: 1 34
    APPEL_FONC (68)
        on left: 40
        on right: 37
    MATH_VAR (69)
        on left: 41 42 43 44 45 46 47 48 49 50
        on right: 36 50 51 52 53 54 55
    MATH_VAR1 (70)
        on left: 51 52 53 54 55 56 57 58 59 60
        on right: 41 42 43 44 45 46 47 48 49 50
    CHAINE_STRING (71)
        on left: 61
        on right: 35
    CHAINE_STRING1 (72)
        on left: 62 63 64
        on right: 61 62 63
    IDFI_CHAR (73)
        on left: 65 66
        on right: 61 62 63
    ES (74)
        on left: 67 68 69
        on right: 28
    ES_WRITE_OPTIONAL (75)
        on left: 70 71
        on right: 69
    Condition (76)
        on left: 72
        on right: 29
    Boucle (77)
        on left: 73
        on right: 30
    Appel (78)
        on left: 74
        on right: 31
    Equivalence (79)
        on left: 75
        on right: 32
    EXPR_CONDI (80)
        on left: 76
        on right: 72 73 82 94
    EXPR_CONDI_TYPE (81)
        on left: 77 78 79 80 81 82
        on right: 76 83
    EXPR_CONDI_SUITE (82)
        on left: 83 84 85
        on right: 76 83
    EXPR_CONDI_OP (83)
        on left: 86 87 88 89 90 91 92 93 94 95
        on right: 83
    Liste (84)
        on left: 96 97
        on right: 1 40 74 75 97
    OPER (85)
        on left: 98 99 100 101
        on right: 51 52 53 54 55 95


State 0

    0 $accept: • Fonction $end

    mcINTEGER    shift, and go to state 1
    mcREAL       shift, and go to state 2
    mcCHARACTER  shift, and go to state 3
    mcLOGICAL    shift, and go to state 4
    mcPROGRAM    shift, and go to state 5

    Fonction  go to state 6
    type      go to state 7


State 1

   21 type: mcINTEGER •

    $default  reduce using rule 21 (type)


State 2

   23 type: mcREAL •

    $default  reduce using rule 23 (type)


State 3

   24 type: mcCHARACTER •

    $default  reduce using rule 24 (type)


State 4

   22 type: mcLOGICAL •

    $default  reduce using rule 22 (type)


State 5

    2 Fonction: mcPROGRAM • identificateur DECLARATIONS INSTR1 mcEND

    identificateur  shift, and go to state 8


State 6

    0 $accept: Fonction • $end

    $end  shift, and go to state 9


State 7

    1 Fonction: type • mcROUTINE identificateur paraO Liste paraF DECLARATIONS INSTR1 identificateur eq EXPR mcENDR Fonction

    mcROUTINE  shift, and go to state 10


State 8

    2 Fonction: mcPROGRAM identificateur • DECLARATIONS INSTR1 mcEND

    mcINTEGER    shift, and go to state 1
    mcREAL       shift, and go to state 2
    mcCHARACTER  shift, and go to state 3
    mcLOGICAL    shift, and go to state 4

    DECLARATIONS  go to state 11
    type          go to state 12


State 9

    0 $accept: Fonction $end •

    $default  accept


State 10

    1 Fonction: type mcROUTINE • identificateur paraO Liste paraF DECLARATIONS INSTR1 identificateur eq EXPR mcENDR Fonction

    identificateur  shift, and go to state 13


State 11

    2 Fonction: mcPROGRAM identificateur DECLARATIONS • INSTR1 mcEND

    $default  reduce using rule 26 (INSTR1)

    INSTR1  go to state 14


State 12

    3 DECLARATIONS: type • identificateur caractere1 DECLARATIONS1

    identificateur  shift, and go to state 15


State 13

    1 Fonction: type mcROUTINE identificateur • paraO Liste paraF DECLARATIONS INSTR1 identificateur eq EXPR mcENDR Fonction

    paraO  shift, and go to state 16


State 14

    2 Fonction: mcPROGRAM identificateur DECLARATIONS INSTR1 • mcEND
   25 INSTR1: INSTR1 • INSTR point_virgule

    mcREAD          shift, and go to state 17
    mcWRITE         shift, and go to state 18
    mcEND           shift, and go to state 19
    mcIF            shift, and go to state 20
    mcDOWHILE       shift, and go to state 21
    PartageMemoire  shift, and go to state 22
    identificateur  shift, and go to state 23

    $default  reduce using rule 33 (INSTR)

    INSTR        go to state 24
    Affectation  go to state 25
    ES           go to state 26
    Condition    go to state 27
    Boucle       go to state 28
    Appel        go to state 29
    Equivalence  go to state 30


State 15

    3 DECLARATIONS: type identificateur • caractere1 DECLARATIONS1

    etoile  shift, and go to state 31

    $default  reduce using rule 5 (caractere1)

    caractere1  go to state 32


State 16

    1 Fonction: type mcROUTINE identificateur paraO • Liste paraF DECLARATIONS INSTR1 identificateur eq EXPR mcENDR Fonction

    identificateur  shift, and go to state 33

    Liste  go to state 34


State 17

   67 ES: mcREAD • paraO identificateur paraF

    paraO  shift, and go to state 35


State 18

   68 ES: mcWRITE • paraO chaine paraF
   69   | mcWRITE • paraO chaine ES_WRITE_OPTIONAL paraF

    paraO  shift, and go to state 36


State 19

    2 Fonction: mcPROGRAM identificateur DECLARATIONS INSTR1 mcEND •

    $default  reduce using rule 2 (Fonction)


State 20

   72 Condition: mcIF • paraO EXPR_CONDI paraF mcTHEN INSTR mcENDIF

    paraO  shift, and go to state 37


State 21

   73 Boucle: mcDOWHILE • paraO EXPR_CONDI paraF INSTR mcENDO

    paraO  shift, and go to state 38


State 22

   75 Equivalence: PartageMemoire • paraO Liste paraF virgule paraO Liste paraF

    paraO  shift, and go to state 39


State 23

   34 Affectation: identificateur • eq EXPR
   74 Appel: identificateur • paraO Liste paraF

    eq     shift, and go to state 40
    paraO  shift, and go to state 41


State 24

   25 INSTR1: INSTR1 INSTR • point_virgule

    point_virgule  shift, and go to state 42


State 25

   27 INSTR: Affectation •

    $default  reduce using rule 27 (INSTR)


State 26

   28 INSTR: ES •

    $default  reduce using rule 28 (INSTR)


State 27

   29 INSTR: Condition •

    $default  reduce using rule 29 (INSTR)


State 28

   30 INSTR: Boucle •

    $default  reduce using rule 30 (INSTR)


State 29

   31 INSTR: Appel •

    $default  reduce using rule 31 (INSTR)


State 30

   32 INSTR: Equivalence •

    $default  reduce using rule 32 (INSTR)


State 31

    4 caractere1: etoile • INTEGER

    INTEGER  shift, and go to state 43


State 32

    3 DECLARATIONS: type identificateur caractere1 • DECLARATIONS1

    mcDIMENSION    shift, and go to state 44
    eq             shift, and go to state 45
    point_virgule  shift, and go to state 46
    virgule        shift, and go to state 47

    DECLARATIONS1  go to state 48


State 33

   96 Liste: identificateur •

    $default  reduce using rule 96 (Liste)


State 34

    1 Fonction: type mcROUTINE identificateur paraO Liste • paraF DECLARATIONS INSTR1 identificateur eq EXPR mcENDR Fonction
   97 Liste: Liste • virgule identificateur

    virgule  shift, and go to state 49
    paraF    shift, and go to state 50


State 35

   67 ES: mcREAD paraO • identificateur paraF

    identificateur  shift, and go to state 51


State 36

   68 ES: mcWRITE paraO • chaine paraF
   69   | mcWRITE paraO • chaine ES_WRITE_OPTIONAL paraF

    chaine  shift, and go to state 52


State 37

   72 Condition: mcIF paraO • EXPR_CONDI paraF mcTHEN INSTR mcENDIF

    mcTRUE          shift, and go to state 53
    mcFALSE         shift, and go to state 54
    paraO           shift, and go to state 55
    identificateur  shift, and go to state 56
    INTEGER         shift, and go to state 57
    REAL            shift, and go to state 58

    EXPR_CONDI       go to state 59
    EXPR_CONDI_TYPE  go to state 60


State 38

   73 Boucle: mcDOWHILE paraO • EXPR_CONDI paraF INSTR mcENDO

    mcTRUE          shift, and go to state 53
    mcFALSE         shift, and go to state 54
    paraO           shift, and go to state 55
    identificateur  shift, and go to state 56
    INTEGER         shift, and go to state 57
    REAL            shift, and go to state 58

    EXPR_CONDI       go to state 61
    EXPR_CONDI_TYPE  go to state 60


State 39

   75 Equivalence: PartageMemoire paraO • Liste paraF virgule paraO Liste paraF

    identificateur  shift, and go to state 33

    Liste  go to state 62


State 40

   34 Affectation: identificateur eq • EXPR

    mcTRUE          shift, and go to state 63
    mcFALSE         shift, and go to state 64
    mcCALL          shift, and go to state 65
    paraO           shift, and go to state 66
    identificateur  shift, and go to state 67
    INTEGER         shift, and go to state 68
    INTEGERPOSITIF  shift, and go to state 69
    INTEGERNEGATIF  shift, and go to state 70
    REAL            shift, and go to state 71
    caracter        shift, and go to state 72
    chaine          shift, and go to state 73
    REALNEGATIF     shift, and go to state 74
    REALPOSITIF     shift, and go to state 75

    EXPR           go to state 76
    APPEL_FONC     go to state 77
    MATH_VAR       go to state 78
    CHAINE_STRING  go to state 79
    IDFI_CHAR      go to state 80


State 41

   74 Appel: identificateur paraO • Liste paraF

    identificateur  shift, and go to state 33

    Liste  go to state 81


State 42

   25 INSTR1: INSTR1 INSTR point_virgule •

    $default  reduce using rule 25 (INSTR1)


State 43

    4 caractere1: etoile INTEGER •

    $default  reduce using rule 4 (caractere1)


State 44

    9 DECLARATIONS1: mcDIMENSION • paraO INTEGER paraF DECLARATIONS2
   10              | mcDIMENSION • paraO INTEGER virgule INTEGER paraF DECLARATIONS2

    paraO  shift, and go to state 82


State 45

   11 DECLARATIONS1: eq • VALEURS DECLARATIONS1

    INTEGER   shift, and go to state 83
    REAL      shift, and go to state 84
    caracter  shift, and go to state 85
    chaine    shift, and go to state 86

    VALEURS  go to state 87


State 46

    6 DECLARATIONS1: point_virgule • DECLARATIONS
    7              | point_virgule •

    mcINTEGER    shift, and go to state 1
    mcREAL       shift, and go to state 2
    mcCHARACTER  shift, and go to state 3
    mcLOGICAL    shift, and go to state 4

    $default  reduce using rule 7 (DECLARATIONS1)

    DECLARATIONS  go to state 88
    type          go to state 12


State 47

    8 DECLARATIONS1: virgule • identificateur caractere1 DECLARATIONS1

    identificateur  shift, and go to state 89


State 48

    3 DECLARATIONS: type identificateur caractere1 DECLARATIONS1 •

    $default  reduce using rule 3 (DECLARATIONS)


State 49

   97 Liste: Liste virgule • identificateur

    identificateur  shift, and go to state 90


State 50

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF • DECLARATIONS INSTR1 identificateur eq EXPR mcENDR Fonction

    mcINTEGER    shift, and go to state 1
    mcREAL       shift, and go to state 2
    mcCHARACTER  shift, and go to state 3
    mcLOGICAL    shift, and go to state 4

    DECLARATIONS  go to state 91
    type          go to state 12


State 51

   67 ES: mcREAD paraO identificateur • paraF

    paraF  shift, and go to state 92


State 52

   68 ES: mcWRITE paraO chaine • paraF
   69   | mcWRITE paraO chaine • ES_WRITE_OPTIONAL paraF

    virgule  shift, and go to state 93
    paraF    shift, and go to state 94

    ES_WRITE_OPTIONAL  go to state 95


State 53

   78 EXPR_CONDI_TYPE: mcTRUE •

    $default  reduce using rule 78 (EXPR_CONDI_TYPE)


State 54

   79 EXPR_CONDI_TYPE: mcFALSE •

    $default  reduce using rule 79 (EXPR_CONDI_TYPE)


State 55

   82 EXPR_CONDI_TYPE: paraO • EXPR_CONDI paraF

    mcTRUE          shift, and go to state 53
    mcFALSE         shift, and go to state 54
    paraO           shift, and go to state 55
    identificateur  shift, and go to state 56
    INTEGER         shift, and go to state 57
    REAL            shift, and go to state 58

    EXPR_CONDI       go to state 96
    EXPR_CONDI_TYPE  go to state 60


State 56

   77 EXPR_CONDI_TYPE: identificateur •

    $default  reduce using rule 77 (EXPR_CONDI_TYPE)


State 57

   80 EXPR_CONDI_TYPE: INTEGER •

    $default  reduce using rule 80 (EXPR_CONDI_TYPE)


State 58

   81 EXPR_CONDI_TYPE: REAL •

    $default  reduce using rule 81 (EXPR_CONDI_TYPE)


State 59

   72 Condition: mcIF paraO EXPR_CONDI • paraF mcTHEN INSTR mcENDIF

    paraF  shift, and go to state 97


State 60

   76 EXPR_CONDI: EXPR_CONDI_TYPE • EXPR_CONDI_SUITE

    OR             shift, and go to state 98
    AND            shift, and go to state 99
    GT             shift, and go to state 100
    EQ             shift, and go to state 101
    GE             shift, and go to state 102
    NE             shift, and go to state 103
    LE             shift, and go to state 104
    LT             shift, and go to state 105
    point_virgule  shift, and go to state 106
    plus           shift, and go to state 107
    mpins          shift, and go to state 108
    division       shift, and go to state 109
    etoile         shift, and go to state 110
    paraO          shift, and go to state 111

    $default  reduce using rule 85 (EXPR_CONDI_SUITE)

    EXPR_CONDI_SUITE  go to state 112
    EXPR_CONDI_OP     go to state 113
    OPER              go to state 114


State 61

   73 Boucle: mcDOWHILE paraO EXPR_CONDI • paraF INSTR mcENDO

    paraF  shift, and go to state 115


State 62

   75 Equivalence: PartageMemoire paraO Liste • paraF virgule paraO Liste paraF
   97 Liste: Liste • virgule identificateur

    virgule  shift, and go to state 49
    paraF    shift, and go to state 116


State 63

   39 EXPR: mcTRUE •

    $default  reduce using rule 39 (EXPR)


State 64

   38 EXPR: mcFALSE •

    $default  reduce using rule 38 (EXPR)


State 65

   40 APPEL_FONC: mcCALL • identificateur paraO Liste paraF

    identificateur  shift, and go to state 117


State 66

   50 MATH_VAR: paraO • MATH_VAR paraF MATH_VAR1

    paraO           shift, and go to state 66
    identificateur  shift, and go to state 67
    INTEGER         shift, and go to state 68
    INTEGERPOSITIF  shift, and go to state 69
    INTEGERNEGATIF  shift, and go to state 70
    REAL            shift, and go to state 71
    REALNEGATIF     shift, and go to state 74
    REALPOSITIF     shift, and go to state 75

    MATH_VAR  go to state 118


State 67

   41 MATH_VAR: identificateur • MATH_VAR1
   42         | identificateur • paraO INTEGER paraF MATH_VAR1
   43         | identificateur • paraO INTEGER virgule INTEGER paraF MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    paraO           shift, and go to state 119
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 124
    OPER       go to state 125


State 68

   44 MATH_VAR: INTEGER • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 126
    OPER       go to state 125


State 69

   45 MATH_VAR: INTEGERPOSITIF • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 127
    OPER       go to state 125


State 70

   46 MATH_VAR: INTEGERNEGATIF • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 128
    OPER       go to state 125


State 71

   47 MATH_VAR: REAL • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 129
    OPER       go to state 125


State 72

   66 IDFI_CHAR: caracter •

    $default  reduce using rule 66 (IDFI_CHAR)


State 73

   65 IDFI_CHAR: chaine •

    $default  reduce using rule 65 (IDFI_CHAR)


State 74

   49 MATH_VAR: REALNEGATIF • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 130
    OPER       go to state 125


State 75

   48 MATH_VAR: REALPOSITIF • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 131
    OPER       go to state 125


State 76

   34 Affectation: identificateur eq EXPR •

    $default  reduce using rule 34 (Affectation)


State 77

   37 EXPR: APPEL_FONC •

    $default  reduce using rule 37 (EXPR)


State 78

   36 EXPR: MATH_VAR •

    $default  reduce using rule 36 (EXPR)


State 79

   35 EXPR: CHAINE_STRING •

    $default  reduce using rule 35 (EXPR)


State 80

   61 CHAINE_STRING: IDFI_CHAR • CHAINE_STRING1

    plus   shift, and go to state 132
    mpins  shift, and go to state 133

    $default  reduce using rule 64 (CHAINE_STRING1)

    CHAINE_STRING1  go to state 134


State 81

   74 Appel: identificateur paraO Liste • paraF
   97 Liste: Liste • virgule identificateur

    virgule  shift, and go to state 49
    paraF    shift, and go to state 135


State 82

    9 DECLARATIONS1: mcDIMENSION paraO • INTEGER paraF DECLARATIONS2
   10              | mcDIMENSION paraO • INTEGER virgule INTEGER paraF DECLARATIONS2

    INTEGER  shift, and go to state 136


State 83

   18 VALEURS: INTEGER •

    $default  reduce using rule 18 (VALEURS)


State 84

   17 VALEURS: REAL •

    $default  reduce using rule 17 (VALEURS)


State 85

   19 VALEURS: caracter •

    $default  reduce using rule 19 (VALEURS)


State 86

   20 VALEURS: chaine •

    $default  reduce using rule 20 (VALEURS)


State 87

   11 DECLARATIONS1: eq VALEURS • DECLARATIONS1

    mcDIMENSION    shift, and go to state 44
    eq             shift, and go to state 45
    point_virgule  shift, and go to state 46
    virgule        shift, and go to state 47

    DECLARATIONS1  go to state 137


State 88

    6 DECLARATIONS1: point_virgule DECLARATIONS •

    $default  reduce using rule 6 (DECLARATIONS1)


State 89

    8 DECLARATIONS1: virgule identificateur • caractere1 DECLARATIONS1

    etoile  shift, and go to state 31

    $default  reduce using rule 5 (caractere1)

    caractere1  go to state 138


State 90

   97 Liste: Liste virgule identificateur •

    $default  reduce using rule 97 (Liste)


State 91

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF DECLARATIONS • INSTR1 identificateur eq EXPR mcENDR Fonction

    $default  reduce using rule 26 (INSTR1)

    INSTR1  go to state 139


State 92

   67 ES: mcREAD paraO identificateur paraF •

    $default  reduce using rule 67 (ES)


State 93

   70 ES_WRITE_OPTIONAL: virgule • identificateur
   71                  | virgule • identificateur chaine

    identificateur  shift, and go to state 140


State 94

   68 ES: mcWRITE paraO chaine paraF •

    $default  reduce using rule 68 (ES)


State 95

   69 ES: mcWRITE paraO chaine ES_WRITE_OPTIONAL • paraF

    paraF  shift, and go to state 141


State 96

   82 EXPR_CONDI_TYPE: paraO EXPR_CONDI • paraF

    paraF  shift, and go to state 142


State 97

   72 Condition: mcIF paraO EXPR_CONDI paraF • mcTHEN INSTR mcENDIF

    mcTHEN  shift, and go to state 143


State 98

   86 EXPR_CONDI_OP: OR •

    $default  reduce using rule 86 (EXPR_CONDI_OP)


State 99

   87 EXPR_CONDI_OP: AND •

    $default  reduce using rule 87 (EXPR_CONDI_OP)


State 100

   88 EXPR_CONDI_OP: GT •

    $default  reduce using rule 88 (EXPR_CONDI_OP)


State 101

   90 EXPR_CONDI_OP: EQ •

    $default  reduce using rule 90 (EXPR_CONDI_OP)


State 102

   89 EXPR_CONDI_OP: GE •

    $default  reduce using rule 89 (EXPR_CONDI_OP)


State 103

   91 EXPR_CONDI_OP: NE •

    $default  reduce using rule 91 (EXPR_CONDI_OP)


State 104

   92 EXPR_CONDI_OP: LE •

    $default  reduce using rule 92 (EXPR_CONDI_OP)


State 105

   93 EXPR_CONDI_OP: LT •

    $default  reduce using rule 93 (EXPR_CONDI_OP)


State 106

   84 EXPR_CONDI_SUITE: point_virgule •

    $default  reduce using rule 84 (EXPR_CONDI_SUITE)


State 107

   98 OPER: plus •

    $default  reduce using rule 98 (OPER)


State 108

   99 OPER: mpins •

    $default  reduce using rule 99 (OPER)


State 109

  101 OPER: division •

    $default  reduce using rule 101 (OPER)


State 110

  100 OPER: etoile •

    $default  reduce using rule 100 (OPER)


State 111

   94 EXPR_CONDI_OP: paraO • EXPR_CONDI paraF

    mcTRUE          shift, and go to state 53
    mcFALSE         shift, and go to state 54
    paraO           shift, and go to state 55
    identificateur  shift, and go to state 56
    INTEGER         shift, and go to state 57
    REAL            shift, and go to state 58

    EXPR_CONDI       go to state 144
    EXPR_CONDI_TYPE  go to state 60


State 112

   76 EXPR_CONDI: EXPR_CONDI_TYPE EXPR_CONDI_SUITE •

    $default  reduce using rule 76 (EXPR_CONDI)


State 113

   83 EXPR_CONDI_SUITE: EXPR_CONDI_OP • EXPR_CONDI_TYPE EXPR_CONDI_SUITE

    mcTRUE          shift, and go to state 53
    mcFALSE         shift, and go to state 54
    paraO           shift, and go to state 55
    identificateur  shift, and go to state 56
    INTEGER         shift, and go to state 57
    REAL            shift, and go to state 58

    EXPR_CONDI_TYPE  go to state 145


State 114

   95 EXPR_CONDI_OP: OPER •

    $default  reduce using rule 95 (EXPR_CONDI_OP)


State 115

   73 Boucle: mcDOWHILE paraO EXPR_CONDI paraF • INSTR mcENDO

    mcREAD          shift, and go to state 17
    mcWRITE         shift, and go to state 18
    mcIF            shift, and go to state 20
    mcDOWHILE       shift, and go to state 21
    PartageMemoire  shift, and go to state 22
    identificateur  shift, and go to state 23

    $default  reduce using rule 33 (INSTR)

    INSTR        go to state 146
    Affectation  go to state 25
    ES           go to state 26
    Condition    go to state 27
    Boucle       go to state 28
    Appel        go to state 29
    Equivalence  go to state 30


State 116

   75 Equivalence: PartageMemoire paraO Liste paraF • virgule paraO Liste paraF

    virgule  shift, and go to state 147


State 117

   40 APPEL_FONC: mcCALL identificateur • paraO Liste paraF

    paraO  shift, and go to state 148


State 118

   50 MATH_VAR: paraO MATH_VAR • paraF MATH_VAR1

    paraF  shift, and go to state 149


State 119

   42 MATH_VAR: identificateur paraO • INTEGER paraF MATH_VAR1
   43         | identificateur paraO • INTEGER virgule INTEGER paraF MATH_VAR1

    INTEGER  shift, and go to state 150


State 120

   53 MATH_VAR1: INTEGERPOSITIF • OPER MATH_VAR
   57          | INTEGERPOSITIF •

    plus      shift, and go to state 107
    mpins     shift, and go to state 108
    division  shift, and go to state 109
    etoile    shift, and go to state 110

    $default  reduce using rule 57 (MATH_VAR1)

    OPER  go to state 151


State 121

   52 MATH_VAR1: INTEGERNEGATIF • OPER MATH_VAR
   56          | INTEGERNEGATIF •

    plus      shift, and go to state 107
    mpins     shift, and go to state 108
    division  shift, and go to state 109
    etoile    shift, and go to state 110

    $default  reduce using rule 56 (MATH_VAR1)

    OPER  go to state 152


State 122

   54 MATH_VAR1: REALNEGATIF • OPER MATH_VAR
   58          | REALNEGATIF •

    plus      shift, and go to state 107
    mpins     shift, and go to state 108
    division  shift, and go to state 109
    etoile    shift, and go to state 110

    $default  reduce using rule 58 (MATH_VAR1)

    OPER  go to state 153


State 123

   55 MATH_VAR1: REALPOSITIF • OPER MATH_VAR
   59          | REALPOSITIF •

    plus      shift, and go to state 107
    mpins     shift, and go to state 108
    division  shift, and go to state 109
    etoile    shift, and go to state 110

    $default  reduce using rule 59 (MATH_VAR1)

    OPER  go to state 154


State 124

   41 MATH_VAR: identificateur MATH_VAR1 •

    $default  reduce using rule 41 (MATH_VAR)


State 125

   51 MATH_VAR1: OPER • MATH_VAR

    paraO           shift, and go to state 66
    identificateur  shift, and go to state 67
    INTEGER         shift, and go to state 68
    INTEGERPOSITIF  shift, and go to state 69
    INTEGERNEGATIF  shift, and go to state 70
    REAL            shift, and go to state 71
    REALNEGATIF     shift, and go to state 74
    REALPOSITIF     shift, and go to state 75

    MATH_VAR  go to state 155


State 126

   44 MATH_VAR: INTEGER MATH_VAR1 •

    $default  reduce using rule 44 (MATH_VAR)


State 127

   45 MATH_VAR: INTEGERPOSITIF MATH_VAR1 •

    $default  reduce using rule 45 (MATH_VAR)


State 128

   46 MATH_VAR: INTEGERNEGATIF MATH_VAR1 •

    $default  reduce using rule 46 (MATH_VAR)


State 129

   47 MATH_VAR: REAL MATH_VAR1 •

    $default  reduce using rule 47 (MATH_VAR)


State 130

   49 MATH_VAR: REALNEGATIF MATH_VAR1 •

    $default  reduce using rule 49 (MATH_VAR)


State 131

   48 MATH_VAR: REALPOSITIF MATH_VAR1 •

    $default  reduce using rule 48 (MATH_VAR)


State 132

   62 CHAINE_STRING1: plus • IDFI_CHAR CHAINE_STRING1

    caracter  shift, and go to state 72
    chaine    shift, and go to state 73

    IDFI_CHAR  go to state 156


State 133

   63 CHAINE_STRING1: mpins • IDFI_CHAR CHAINE_STRING1

    caracter  shift, and go to state 72
    chaine    shift, and go to state 73

    IDFI_CHAR  go to state 157


State 134

   61 CHAINE_STRING: IDFI_CHAR CHAINE_STRING1 •

    $default  reduce using rule 61 (CHAINE_STRING)


State 135

   74 Appel: identificateur paraO Liste paraF •

    $default  reduce using rule 74 (Appel)


State 136

    9 DECLARATIONS1: mcDIMENSION paraO INTEGER • paraF DECLARATIONS2
   10              | mcDIMENSION paraO INTEGER • virgule INTEGER paraF DECLARATIONS2

    virgule  shift, and go to state 158
    paraF    shift, and go to state 159


State 137

   11 DECLARATIONS1: eq VALEURS DECLARATIONS1 •

    $default  reduce using rule 11 (DECLARATIONS1)


State 138

    8 DECLARATIONS1: virgule identificateur caractere1 • DECLARATIONS1

    mcDIMENSION    shift, and go to state 44
    eq             shift, and go to state 45
    point_virgule  shift, and go to state 46
    virgule        shift, and go to state 47

    DECLARATIONS1  go to state 160


State 139

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF DECLARATIONS INSTR1 • identificateur eq EXPR mcENDR Fonction
   25 INSTR1: INSTR1 • INSTR point_virgule

    mcREAD          shift, and go to state 17
    mcWRITE         shift, and go to state 18
    mcIF            shift, and go to state 20
    mcDOWHILE       shift, and go to state 21
    PartageMemoire  shift, and go to state 22
    identificateur  shift, and go to state 161

    $default  reduce using rule 33 (INSTR)

    INSTR        go to state 24
    Affectation  go to state 25
    ES           go to state 26
    Condition    go to state 27
    Boucle       go to state 28
    Appel        go to state 29
    Equivalence  go to state 30


State 140

   70 ES_WRITE_OPTIONAL: virgule identificateur •
   71                  | virgule identificateur • chaine

    chaine  shift, and go to state 162

    $default  reduce using rule 70 (ES_WRITE_OPTIONAL)


State 141

   69 ES: mcWRITE paraO chaine ES_WRITE_OPTIONAL paraF •

    $default  reduce using rule 69 (ES)


State 142

   82 EXPR_CONDI_TYPE: paraO EXPR_CONDI paraF •

    $default  reduce using rule 82 (EXPR_CONDI_TYPE)


State 143

   72 Condition: mcIF paraO EXPR_CONDI paraF mcTHEN • INSTR mcENDIF

    mcREAD          shift, and go to state 17
    mcWRITE         shift, and go to state 18
    mcIF            shift, and go to state 20
    mcDOWHILE       shift, and go to state 21
    PartageMemoire  shift, and go to state 22
    identificateur  shift, and go to state 23

    $default  reduce using rule 33 (INSTR)

    INSTR        go to state 163
    Affectation  go to state 25
    ES           go to state 26
    Condition    go to state 27
    Boucle       go to state 28
    Appel        go to state 29
    Equivalence  go to state 30


State 144

   94 EXPR_CONDI_OP: paraO EXPR_CONDI • paraF

    paraF  shift, and go to state 164


State 145

   83 EXPR_CONDI_SUITE: EXPR_CONDI_OP EXPR_CONDI_TYPE • EXPR_CONDI_SUITE

    OR             shift, and go to state 98
    AND            shift, and go to state 99
    GT             shift, and go to state 100
    EQ             shift, and go to state 101
    GE             shift, and go to state 102
    NE             shift, and go to state 103
    LE             shift, and go to state 104
    LT             shift, and go to state 105
    point_virgule  shift, and go to state 106
    plus           shift, and go to state 107
    mpins          shift, and go to state 108
    division       shift, and go to state 109
    etoile         shift, and go to state 110
    paraO          shift, and go to state 111

    $default  reduce using rule 85 (EXPR_CONDI_SUITE)

    EXPR_CONDI_SUITE  go to state 165
    EXPR_CONDI_OP     go to state 113
    OPER              go to state 114


State 146

   73 Boucle: mcDOWHILE paraO EXPR_CONDI paraF INSTR • mcENDO

    mcENDO  shift, and go to state 166


State 147

   75 Equivalence: PartageMemoire paraO Liste paraF virgule • paraO Liste paraF

    paraO  shift, and go to state 167


State 148

   40 APPEL_FONC: mcCALL identificateur paraO • Liste paraF

    identificateur  shift, and go to state 33

    Liste  go to state 168


State 149

   50 MATH_VAR: paraO MATH_VAR paraF • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 169
    OPER       go to state 125


State 150

   42 MATH_VAR: identificateur paraO INTEGER • paraF MATH_VAR1
   43         | identificateur paraO INTEGER • virgule INTEGER paraF MATH_VAR1

    virgule  shift, and go to state 170
    paraF    shift, and go to state 171


State 151

   53 MATH_VAR1: INTEGERPOSITIF OPER • MATH_VAR

    paraO           shift, and go to state 66
    identificateur  shift, and go to state 67
    INTEGER         shift, and go to state 68
    INTEGERPOSITIF  shift, and go to state 69
    INTEGERNEGATIF  shift, and go to state 70
    REAL            shift, and go to state 71
    REALNEGATIF     shift, and go to state 74
    REALPOSITIF     shift, and go to state 75

    MATH_VAR  go to state 172


State 152

   52 MATH_VAR1: INTEGERNEGATIF OPER • MATH_VAR

    paraO           shift, and go to state 66
    identificateur  shift, and go to state 67
    INTEGER         shift, and go to state 68
    INTEGERPOSITIF  shift, and go to state 69
    INTEGERNEGATIF  shift, and go to state 70
    REAL            shift, and go to state 71
    REALNEGATIF     shift, and go to state 74
    REALPOSITIF     shift, and go to state 75

    MATH_VAR  go to state 173


State 153

   54 MATH_VAR1: REALNEGATIF OPER • MATH_VAR

    paraO           shift, and go to state 66
    identificateur  shift, and go to state 67
    INTEGER         shift, and go to state 68
    INTEGERPOSITIF  shift, and go to state 69
    INTEGERNEGATIF  shift, and go to state 70
    REAL            shift, and go to state 71
    REALNEGATIF     shift, and go to state 74
    REALPOSITIF     shift, and go to state 75

    MATH_VAR  go to state 174


State 154

   55 MATH_VAR1: REALPOSITIF OPER • MATH_VAR

    paraO           shift, and go to state 66
    identificateur  shift, and go to state 67
    INTEGER         shift, and go to state 68
    INTEGERPOSITIF  shift, and go to state 69
    INTEGERNEGATIF  shift, and go to state 70
    REAL            shift, and go to state 71
    REALNEGATIF     shift, and go to state 74
    REALPOSITIF     shift, and go to state 75

    MATH_VAR  go to state 175


State 155

   51 MATH_VAR1: OPER MATH_VAR •

    $default  reduce using rule 51 (MATH_VAR1)


State 156

   62 CHAINE_STRING1: plus IDFI_CHAR • CHAINE_STRING1

    plus   shift, and go to state 132
    mpins  shift, and go to state 133

    $default  reduce using rule 64 (CHAINE_STRING1)

    CHAINE_STRING1  go to state 176


State 157

   63 CHAINE_STRING1: mpins IDFI_CHAR • CHAINE_STRING1

    plus   shift, and go to state 132
    mpins  shift, and go to state 133

    $default  reduce using rule 64 (CHAINE_STRING1)

    CHAINE_STRING1  go to state 177


State 158

   10 DECLARATIONS1: mcDIMENSION paraO INTEGER virgule • INTEGER paraF DECLARATIONS2

    INTEGER  shift, and go to state 178


State 159

    9 DECLARATIONS1: mcDIMENSION paraO INTEGER paraF • DECLARATIONS2

    mcDIMENSION    shift, and go to state 179
    point_virgule  shift, and go to state 180
    virgule        shift, and go to state 181

    DECLARATIONS2  go to state 182


State 160

    8 DECLARATIONS1: virgule identificateur caractere1 DECLARATIONS1 •

    $default  reduce using rule 8 (DECLARATIONS1)


State 161

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF DECLARATIONS INSTR1 identificateur • eq EXPR mcENDR Fonction
   34 Affectation: identificateur • eq EXPR
   74 Appel: identificateur • paraO Liste paraF

    eq     shift, and go to state 183
    paraO  shift, and go to state 41


State 162

   71 ES_WRITE_OPTIONAL: virgule identificateur chaine •

    $default  reduce using rule 71 (ES_WRITE_OPTIONAL)


State 163

   72 Condition: mcIF paraO EXPR_CONDI paraF mcTHEN INSTR • mcENDIF

    mcENDIF  shift, and go to state 184


State 164

   94 EXPR_CONDI_OP: paraO EXPR_CONDI paraF •

    $default  reduce using rule 94 (EXPR_CONDI_OP)


State 165

   83 EXPR_CONDI_SUITE: EXPR_CONDI_OP EXPR_CONDI_TYPE EXPR_CONDI_SUITE •

    $default  reduce using rule 83 (EXPR_CONDI_SUITE)


State 166

   73 Boucle: mcDOWHILE paraO EXPR_CONDI paraF INSTR mcENDO •

    $default  reduce using rule 73 (Boucle)


State 167

   75 Equivalence: PartageMemoire paraO Liste paraF virgule paraO • Liste paraF

    identificateur  shift, and go to state 33

    Liste  go to state 185


State 168

   40 APPEL_FONC: mcCALL identificateur paraO Liste • paraF
   97 Liste: Liste • virgule identificateur

    virgule  shift, and go to state 49
    paraF    shift, and go to state 186


State 169

   50 MATH_VAR: paraO MATH_VAR paraF MATH_VAR1 •

    $default  reduce using rule 50 (MATH_VAR)


State 170

   43 MATH_VAR: identificateur paraO INTEGER virgule • INTEGER paraF MATH_VAR1

    INTEGER  shift, and go to state 187


State 171

   42 MATH_VAR: identificateur paraO INTEGER paraF • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 188
    OPER       go to state 125


State 172

   53 MATH_VAR1: INTEGERPOSITIF OPER MATH_VAR •

    $default  reduce using rule 53 (MATH_VAR1)


State 173

   52 MATH_VAR1: INTEGERNEGATIF OPER MATH_VAR •

    $default  reduce using rule 52 (MATH_VAR1)


State 174

   54 MATH_VAR1: REALNEGATIF OPER MATH_VAR •

    $default  reduce using rule 54 (MATH_VAR1)


State 175

   55 MATH_VAR1: REALPOSITIF OPER MATH_VAR •

    $default  reduce using rule 55 (MATH_VAR1)


State 176

   62 CHAINE_STRING1: plus IDFI_CHAR CHAINE_STRING1 •

    $default  reduce using rule 62 (CHAINE_STRING1)


State 177

   63 CHAINE_STRING1: mpins IDFI_CHAR CHAINE_STRING1 •

    $default  reduce using rule 63 (CHAINE_STRING1)


State 178

   10 DECLARATIONS1: mcDIMENSION paraO INTEGER virgule INTEGER • paraF DECLARATIONS2

    paraF  shift, and go to state 189


State 179

   15 DECLARATIONS2: mcDIMENSION • paraO INTEGER paraF DECLARATIONS1
   16              | mcDIMENSION • paraO INTEGER virgule INTEGER paraF DECLARATIONS1

    paraO  shift, and go to state 190


State 180

   12 DECLARATIONS2: point_virgule • DECLARATIONS
   13              | point_virgule •

    mcINTEGER    shift, and go to state 1
    mcREAL       shift, and go to state 2
    mcCHARACTER  shift, and go to state 3
    mcLOGICAL    shift, and go to state 4

    $default  reduce using rule 13 (DECLARATIONS2)

    DECLARATIONS  go to state 191
    type          go to state 12


State 181

   14 DECLARATIONS2: virgule • identificateur caractere1 DECLARATIONS1

    identificateur  shift, and go to state 192


State 182

    9 DECLARATIONS1: mcDIMENSION paraO INTEGER paraF DECLARATIONS2 •

    $default  reduce using rule 9 (DECLARATIONS1)


State 183

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF DECLARATIONS INSTR1 identificateur eq • EXPR mcENDR Fonction
   34 Affectation: identificateur eq • EXPR

    mcTRUE          shift, and go to state 63
    mcFALSE         shift, and go to state 64
    mcCALL          shift, and go to state 65
    paraO           shift, and go to state 66
    identificateur  shift, and go to state 67
    INTEGER         shift, and go to state 68
    INTEGERPOSITIF  shift, and go to state 69
    INTEGERNEGATIF  shift, and go to state 70
    REAL            shift, and go to state 71
    caracter        shift, and go to state 72
    chaine          shift, and go to state 73
    REALNEGATIF     shift, and go to state 74
    REALPOSITIF     shift, and go to state 75

    EXPR           go to state 193
    APPEL_FONC     go to state 77
    MATH_VAR       go to state 78
    CHAINE_STRING  go to state 79
    IDFI_CHAR      go to state 80


State 184

   72 Condition: mcIF paraO EXPR_CONDI paraF mcTHEN INSTR mcENDIF •

    $default  reduce using rule 72 (Condition)


State 185

   75 Equivalence: PartageMemoire paraO Liste paraF virgule paraO Liste • paraF
   97 Liste: Liste • virgule identificateur

    virgule  shift, and go to state 49
    paraF    shift, and go to state 194


State 186

   40 APPEL_FONC: mcCALL identificateur paraO Liste paraF •

    $default  reduce using rule 40 (APPEL_FONC)


State 187

   43 MATH_VAR: identificateur paraO INTEGER virgule INTEGER • paraF MATH_VAR1

    paraF  shift, and go to state 195


State 188

   42 MATH_VAR: identificateur paraO INTEGER paraF MATH_VAR1 •

    $default  reduce using rule 42 (MATH_VAR)


State 189

   10 DECLARATIONS1: mcDIMENSION paraO INTEGER virgule INTEGER paraF • DECLARATIONS2

    mcDIMENSION    shift, and go to state 179
    point_virgule  shift, and go to state 180
    virgule        shift, and go to state 181

    DECLARATIONS2  go to state 196


State 190

   15 DECLARATIONS2: mcDIMENSION paraO • INTEGER paraF DECLARATIONS1
   16              | mcDIMENSION paraO • INTEGER virgule INTEGER paraF DECLARATIONS1

    INTEGER  shift, and go to state 197


State 191

   12 DECLARATIONS2: point_virgule DECLARATIONS •

    $default  reduce using rule 12 (DECLARATIONS2)


State 192

   14 DECLARATIONS2: virgule identificateur • caractere1 DECLARATIONS1

    etoile  shift, and go to state 31

    $default  reduce using rule 5 (caractere1)

    caractere1  go to state 198


State 193

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF DECLARATIONS INSTR1 identificateur eq EXPR • mcENDR Fonction
   34 Affectation: identificateur eq EXPR •

    mcENDR  shift, and go to state 199

    $default  reduce using rule 34 (Affectation)


State 194

   75 Equivalence: PartageMemoire paraO Liste paraF virgule paraO Liste paraF •

    $default  reduce using rule 75 (Equivalence)


State 195

   43 MATH_VAR: identificateur paraO INTEGER virgule INTEGER paraF • MATH_VAR1

    plus            shift, and go to state 107
    mpins           shift, and go to state 108
    division        shift, and go to state 109
    etoile          shift, and go to state 110
    INTEGERPOSITIF  shift, and go to state 120
    INTEGERNEGATIF  shift, and go to state 121
    REALNEGATIF     shift, and go to state 122
    REALPOSITIF     shift, and go to state 123

    $default  reduce using rule 60 (MATH_VAR1)

    MATH_VAR1  go to state 200
    OPER       go to state 125


State 196

   10 DECLARATIONS1: mcDIMENSION paraO INTEGER virgule INTEGER paraF DECLARATIONS2 •

    $default  reduce using rule 10 (DECLARATIONS1)


State 197

   15 DECLARATIONS2: mcDIMENSION paraO INTEGER • paraF DECLARATIONS1
   16              | mcDIMENSION paraO INTEGER • virgule INTEGER paraF DECLARATIONS1

    virgule  shift, and go to state 201
    paraF    shift, and go to state 202


State 198

   14 DECLARATIONS2: virgule identificateur caractere1 • DECLARATIONS1

    mcDIMENSION    shift, and go to state 44
    eq             shift, and go to state 45
    point_virgule  shift, and go to state 46
    virgule        shift, and go to state 47

    DECLARATIONS1  go to state 203


State 199

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF DECLARATIONS INSTR1 identificateur eq EXPR mcENDR • Fonction

    mcINTEGER    shift, and go to state 1
    mcREAL       shift, and go to state 2
    mcCHARACTER  shift, and go to state 3
    mcLOGICAL    shift, and go to state 4
    mcPROGRAM    shift, and go to state 5

    Fonction  go to state 204
    type      go to state 7


State 200

   43 MATH_VAR: identificateur paraO INTEGER virgule INTEGER paraF MATH_VAR1 •

    $default  reduce using rule 43 (MATH_VAR)


State 201

   16 DECLARATIONS2: mcDIMENSION paraO INTEGER virgule • INTEGER paraF DECLARATIONS1

    INTEGER  shift, and go to state 205


State 202

   15 DECLARATIONS2: mcDIMENSION paraO INTEGER paraF • DECLARATIONS1

    mcDIMENSION    shift, and go to state 44
    eq             shift, and go to state 45
    point_virgule  shift, and go to state 46
    virgule        shift, and go to state 47

    DECLARATIONS1  go to state 206


State 203

   14 DECLARATIONS2: virgule identificateur caractere1 DECLARATIONS1 •

    $default  reduce using rule 14 (DECLARATIONS2)


State 204

    1 Fonction: type mcROUTINE identificateur paraO Liste paraF DECLARATIONS INSTR1 identificateur eq EXPR mcENDR Fonction •

    $default  reduce using rule 1 (Fonction)


State 205

   16 DECLARATIONS2: mcDIMENSION paraO INTEGER virgule INTEGER • paraF DECLARATIONS1

    paraF  shift, and go to state 207


State 206

   15 DECLARATIONS2: mcDIMENSION paraO INTEGER paraF DECLARATIONS1 •

    $default  reduce using rule 15 (DECLARATIONS2)


State 207

   16 DECLARATIONS2: mcDIMENSION paraO INTEGER virgule INTEGER paraF • DECLARATIONS1

    mcDIMENSION    shift, and go to state 44
    eq             shift, and go to state 45
    point_virgule  shift, and go to state 46
    virgule        shift, and go to state 47

    DECLARATIONS1  go to state 208


State 208

   16 DECLARATIONS2: mcDIMENSION paraO INTEGER virgule INTEGER paraF DECLARATIONS1 •

    $default  reduce using rule 16 (DECLARATIONS2)
